1:"$Sreact.fragment"
3:I[6874,["874","static/chunks/874-8968dd5eb7fadb60.js","48","static/chunks/app/%5B...slug%5D/page-526665be0f2fd5b4.js"],""]
4:I[7555,[],""]
5:I[1295,[],""]
7:I[9665,[],"OutletBoundary"]
a:I[9665,[],"ViewportBoundary"]
c:I[9665,[],"MetadataBoundary"]
e:I[6614,[],""]
:HL["/_next/static/css/fad3d6b35e924199.css","style"]
:HL["/_next/static/css/c2b8ef241a0bd383.css","style"]
:HL["/_next/static/css/13f49b5dcd295dae.css","style"]
0:{"P":null,"b":"A_h_n7CBt7_bpyguSodXu","p":"","c":["","2019","01","the-lost-callback",""],"i":false,"f":[[["",{"children":[["slug","2019/01/the-lost-callback","c"],{"children":["__PAGE__",{}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/fad3d6b35e924199.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],"$L2"]}],{"children":[["slug","2019/01/the-lost-callback","c"],["$","$1","c",{"children":[null,[["$","$L3",null,{"href":"/","children":"‚Üê go home"}],["$","$L4",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L6","$undefined",[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/c2b8ef241a0bd383.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/css/13f49b5dcd295dae.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","$L7",null,{"children":["$L8","$L9",null]}]]}],{},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","6tLCU-2RBOIeL6svCqdvi",{"children":[["$","$La",null,{"children":"$Lb"}],null]}],["$","$Lc",null,{"children":"$Ld"}]]}],false]],"m":"$undefined","G":["$e","$undefined"],"s":false,"S":true}
2:["$","html",null,{"lang":"en-us","children":["$","body",null,{"children":["$","div",null,{"className":"container_container__2GGUi","children":["$","main",null,{"children":["$","$L4",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}]}]}]}]
b:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
8:null
f:T4676,
<p>
  In the past few days I was investigating a really tricky issue in one of our
  React components. I decided to cover it here because I've found the problem
  interesting and, surprisingly, easy to fix after finding out the root cause.
</p>
<h1>The Component</h1>
<p>
  First, it's nice to outline a little bit about the component itself. It's a
  really simple react component that does the following things:
</p>
<ol>
  <li>
    When the component mounts, inserts a <code>&#x3C;script></code> tag on the page to load an
    external dependency
  </li>
  <li>
    When this script is loaded, instantiate a new instance of this external
    dependency
  </li>
  <li>Renders correctly both when script is loaded and when it isn't</li>
  <li>When removing the component, destroys the external dependency instance</li>
</ol>
<p>So, that said, lets jump into the parts that make it happen.</p>
<p>First, we have the script loader function, which is pretty straightforward:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addScriptToPage</span>(<span class="hljs-params">callback, src</span>) {
    <span class="hljs-keyword">const</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'script'</span>);

    script.<span class="hljs-property">defer</span> = <span class="hljs-literal">true</span>;
    script.<span class="hljs-property">onload</span> = callback;
    script.<span class="hljs-property">src</span> = src;

    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(script);
}
</code></pre>
<p>The component itself is also pretty straightforward:</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TheComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {
        <span class="hljs-variable language_">super</span>(props);

        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = {
            <span class="hljs-attr">externalDependency</span>: <span class="hljs-literal">null</span>,
        };
    }

    <span class="hljs-title function_">componentWillMount</span>(<span class="hljs-params"></span>) {
        <span class="hljs-title function_">addScriptToPage</span>(<span class="hljs-function">() =></span> {
            <span class="hljs-keyword">const</span> externalDependency = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExternalDependency</span>();
            externalDependency.<span class="hljs-title function_">create</span>();

            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({
                externalDependency,
            });
        }, <span class="hljs-string">'external.js'</span>);
    }

    <span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">const</span> { externalDependency } = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>;

        externalDependency &#x26;&#x26; externalDependency.<span class="hljs-title function_">destroy</span>();
    }

    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">const</span> { externalDependency } = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>;
        <span class="hljs-keyword">const</span> value = externalDependency
            ?  externalDependency.<span class="hljs-title function_">doStuff</span>()
            : <span class="hljs-string">'NOT LOADED YET'</span>;

        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>External value: {value}<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span></span>;
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {
        <span class="hljs-variable language_">super</span>(props);

        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = {
            <span class="hljs-attr">hide</span>: <span class="hljs-literal">false</span>,
        };
    }

    <span class="hljs-title function_">componentWillMount</span>(<span class="hljs-params"></span>) {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function">() =></span> ({
                <span class="hljs-attr">hide</span>: <span class="hljs-literal">true</span>,
            }));
        }, <span class="hljs-number">0</span>);
    }

    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">hide</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">TheComponent</span> /></span></span>;
    }
}
</code></pre>
<p>
  The external dependency, for all the purposes, is just a library. In our case,
  the real one listens to some events and some other stuff. For this post,
  consider the following external dependency:
</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ExternalDependency</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">create</span>: <span class="hljs-function">() =></span> {
            <span class="hljs-variable language_">window</span>.<span class="hljs-property">EXTERNAL</span> = <span class="hljs-string">'EXTERNAL'</span>;
        },

        <span class="hljs-attr">doStuff</span>: <span class="hljs-function">() =></span> {
            <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;
        },

        <span class="hljs-attr">destroy</span>: <span class="hljs-function">() =></span> {
            <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">window</span>.<span class="hljs-property">EXTERNAL</span>;
        },
    };
}
</code></pre>
<h1>The Problem</h1>
<p>The problem given was the following:</p>
<blockquote>
  <p>
    When we include the component on the page and, right afterwards remove it from
    the page, the component throws an error and the page stops working.
  </p>
</blockquote>
<p>Alongside with the error description, we also had the following log:</p>
<pre><code>TypeError: this.state.externalDependency is null
</code></pre>
<h1>The Test Setup</h1>
<p>
  So, in order to test this problem, we need to simulate this "right afterwards"
  behavior. To do so, we'll render the component on the page, set a timeout (a
  short one) and remove the component from the screen.
</p>
<p>Consider the following code:</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {
        <span class="hljs-variable language_">super</span>(props);

        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = {
            <span class="hljs-attr">hide</span>: <span class="hljs-literal">false</span>,
        };
    }

    <span class="hljs-title function_">componentWillMount</span>(<span class="hljs-params"></span>) {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function">() =></span> ({
                <span class="hljs-attr">hide</span>: <span class="hljs-literal">true</span>,
            }));
        }, <span class="hljs-number">0</span>);
    }

    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">hide</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">TheComponent</span> /></span></span>;
    }
}
</code></pre>
<h1>The Investigation</h1>
<p>
  <strong>Disclaimer:</strong> now that I'm explaining this in a blog post, the problem seems
  obvious to me. I think this is because the code shown here is really simplified. The real code has some messy parts, some reducers and lots of code that only
  made the investigation progress harder.
</p>
<p>
  Looking at the code, we can see that the only place where
  <code>this.state.externalDependency</code> can cause this error is inside
  <code>componentWillUnmount</code>, because it starts as <code>null</code>. So, what happens is that
  the script hasn't finished loading and we're trying to destroy the instance
  (that doesn't exist yet).
</p>
<p>So, it might be tempting to do the following:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> { externalDependency } = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>;

<span class="hljs-keyword">if</span> (externalDependency) {
    externalDependency.<span class="hljs-title function_">destroy</span>();
}
</code></pre>
<p>
  It will make the page stop breaking, as now we don't have a <code>TypeError</code>,
  however, we will start having this error:
</p>
<pre><code>Warning: Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.
</code></pre>
<p>
  You might think that it's only a <code>Warning</code> and we're good to go, however, that's
  not how things work. Now, we <strong>never</strong> call <code>externalDependency.destroy()</code>, so,
  we never clear the changes done by <code>externalDependency</code>. In fact, if we now
  check <code>window.EXTERNAL</code>, we'll have it with the value <code>"EXTERNAL"</code>.
</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">window</span>.<span class="hljs-property">EXTERNAL</span>; <span class="hljs-comment">// "EXTERNAL"</span>
</code></pre>
<h2>Making It Clear</h2>
<p>So, let's recap what's going on, before exploring the solution:</p>
<ol>
  <li>The component is rendered on the page</li>
  <li>
    The script pointing to <code>external.js</code> is created on the page, a callback is
    registered to, when the script loads, instantiate an instance of
    <code>ExternalDependency</code>
  </li>
  <li>The component is removed</li>
  <li>
    The <code>componentWillUnmount</code> is triggered (not calling
    <code>externalDependency.destroy()</code>, as it wasn't instantiated so far)
  </li>
  <li>The component is removed from the DOM</li>
  <li>The script finishes loading</li>
  <li>The callback defined in <code>2.</code> is executed</li>
  <li>The external dependency is instantiated</li>
  <li>
    The component tries to <code>setState</code> in an unmounted component, which explains
    the error before
  </li>
</ol>
<h1>The Solution</h1>
<p>
  While it can be tempting to put something on <code>componentWillUnmount</code>, like a
  <code>setState</code> or so, it is not correct and also doesn't make sense.
  <code>componentWillUnmount</code> is called when the component is just about to be removed,
  there's no "hey React, wait a little bit so I can make some stuff here
  and I let you know when you can remove me". Also, setting a state on a component
  to be unmounted doesn't make sense, as this component is being removed, it will
  not render again nor go to any other <code>lifecycle</code> methods.
</p>
<h2>Solution 1: Know When Unmounted</h2>
<p>
  One solution that I particularly <strong>don't like</strong> is to have an instance property in
  your component that allows you to know if the component is being unmounted.
  Something like that:
</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isUnmounted</span> = <span class="hljs-literal">true</span>;
    <span class="hljs-comment">/* ... remaining code ... */</span>
}
</code></pre>
<p>
  Then, add a guard condition in your code to avoid the callback to run in this
  case:
</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">addScriptToPage</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">isUnmounted</span>) <span class="hljs-keyword">return</span>
    <span class="hljs-comment">/* ... remaining code ... */</span>
})
</code></pre>
<p>
  This works, however, imagine that in some new update, the React team decides to
  clear all instance properties (our <code>isUnmounted</code> included). We now have our
  memory leak again. Basically, with this solution, we're relying on React to set
  a property for us and set it in the correct moment, which gives us less control
  of our code flow.
</p>
<h2>Solution 2: Control When to Execute the <code>onload</code> Callback</h2>
<p>
  Our final solution and, in my opinion, a most elegant one, is to have an option
  to cancel the execution of our script loader. Our problem is that the <code>onload</code>
  callback is being called after the component is unmounted, so, if we never call
  this callback, we'll not have this problem.
</p>
<p>In this case, we can do something like that:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addScriptToPage</span>(<span class="hljs-params">callback, src</span>) {
    <span class="hljs-keyword">const</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'script'</span>);

    script.<span class="hljs-property">src</span> = src;
    script.<span class="hljs-property">defer</span> = <span class="hljs-literal">true</span>;
    script.<span class="hljs-property">onload</span> = callback;

    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(script);

    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">cancelOnLoad</span>: <span class="hljs-function">() =></span> script.<span class="hljs-property">onload</span> = <span class="hljs-literal">null</span>,
    };
}
</code></pre>
<p>
  Now, in our component, we need to hold a reference to this returned object when
  calling <code>addScriptToPage</code>:
</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">componentWillMount</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> scriptLoader = <span class="hljs-title function_">addScriptToPage</span>(<span class="hljs-function">() =></span> {<span class="hljs-comment">/* remaining code */</span>});
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ scriptLoader });
}
</code></pre>
<p>Then, when unmounting, we just call <code>cancelOnLoad</code>:</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">/* remaining code */</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">scriptLoader</span>.<span class="hljs-title function_">cancelOnLoad</span>();
}
</code></pre>
<p>
  This is a lot better, as now we manage this flow. For example, it's also
  possible to remove the previously defined script (and save some bytes of our
  users data):
</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">return</span> {
    <span class="hljs-attr">cancelOnLoad</span>: <span class="hljs-function">() =></span> {
        script.<span class="hljs-property">onload</span> = <span class="hljs-literal">null</span>;
        <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(script);
    },
};
</code></pre>
<h1>Finishing</h1>
<p>
  I think this problem was really interesting to show me how a simple script
  loader can become a hard problem to debug if we don't think correctly in the
  flow which our code is executed.
</p>
<p>
  Also, always remember to cancel/clear stuff, specially the async ones, to avoid
  having those kind of problems.
</p>
6:["$","article",null,{"children":[["$","div",null,{"className":"page_titleContainer__tlZMv","children":[["$","h1",null,{"className":"page_title__Tljh5","children":"The Lost Callback"}],["$","time",null,{"className":"datetime_datetime__ZMgNO","dateTime":"12:19:19 AM","children":"Jan 3, 2019"}]]}],["$","div",null,{"className":"page_post__iBPNz","dangerouslySetInnerHTML":{"__html":"$f"}}],["$","footer",null,{"className":"page_footer__MFEyq","children":["Tags:"," ",[["$","$L3","react",{"className":"page_tag__9Ktix","href":"/tags/react","children":"react"}],["$","$L3","async-javascript",{"className":"page_tag__9Ktix","href":"/tags/async-javascript","children":"async javascript"}]]]}]]}]
9:null
d:[["$","title","0",{"children":"The Lost Callback"}],["$","meta","1",{"name":"description","content":"In the past few days I was investigating a really tricky issue in one of our\nReact components. I decided to cover it here because I've..."}],["$","meta","2",{"property":"og:title","content":"The Lost Callback"}],["$","meta","3",{"property":"og:description","content":"In the past few days I was investigating a really tricky issue in one of our\nReact components. I decided to cover it here because I've..."}],["$","meta","4",{"name":"twitter:card","content":"summary"}],["$","meta","5",{"name":"twitter:title","content":"The Lost Callback"}],["$","meta","6",{"name":"twitter:description","content":"In the past few days I was investigating a really tricky issue in one of our\nReact components. I decided to cover it here because I've..."}]]
