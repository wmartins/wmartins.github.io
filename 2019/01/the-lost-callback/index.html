<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>The Lost Callback - wwwhmartins</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="">
  <meta name="keywords" content="">
  <link rel="canonical" href="https://wmartins.github.io/2019/01/the-lost-callback/">

  
  

  
  

  
  

  <link rel="stylesheet" type="text/css" href="https://wmartins.github.io/css/combined-min.css">
  <link rel="stylesheet" type="text/css" href="https://wmartins.github.io/tipuesearch/tipuesearch.css">

</head>
<body class="">

<div class="site-wrap">
  <header class="site-header px2 px-responsive">
  <div class="mt2 wrap">
    <div class="measure">
      <a href="https://wmartins.github.io" class="site-title">wwwhmartins</a>
      <nav class="site-nav right">
      <a href="https://wmartins.github.io/about/">About</a>
<a href="https://wmartins.github.io/tags/">Tags</a>
<a href="https://wmartins.github.io/contact/">Contact</a>
</form>

      </nav>
      <div class="clearfix"></div>
    </div>
  </div>
</header>

  <div class="post p2 p-responsive wrap" role="main">
    <div class="measure">
      <div class="post-header mb2">
        <h1 class="py2">The Lost Callback</h1>
        <span class="post-meta">Jan 3, 2019 by William Martins</span><br>
        
      </div>

      <article class="post-content">
      

<p>In the past few days I was investigating a really tricky issue in one of our
React components. I decided to cover it here because I&rsquo;ve found the problem
interesting and, surprisingly, easy to fix after finding out the root cause.</p>

<h1 id="the-component">The Component</h1>

<p>First, it&rsquo;s nice to outline a little bit about the component itself. It&rsquo;s a
really simple react component that does the following things:</p>

<ol>
<li>When the component mounts, inserts a <code>&lt;script&gt;</code> tag on the page to load an
external dependency</li>
<li>When this script is loaded, instantiate a new instance of this external
dependency</li>
<li>Renders correctly both when script is loaded and when it isn&rsquo;t</li>
<li>When removing the component, destroys the external dependency instance</li>
</ol>

<p>So, that said, lets jump into the parts that make it happen.</p>

<p>First, we have the script loader function, which is pretty straightforward:</p>

<pre><code class="language-js">function addScriptToPage(callback, src) {
    const script = document.createElement('script');

    script.defer = true;
    script.onload = callback;
    script.src = src;

    document.body.appendChild(script);
}
</code></pre>

<p>The component itself is also pretty straightforward:</p>

<pre><code class="language-jsx">class TheComponent extends Component {
    constructor(props) {
        super(props);

        this.state = {
            externalDependency: null,
        };
    }

    componentWillMount() {
        addScriptToPage(() =&gt; {
            const externalDependency = new ExternalDependency();
            externalDependency.create();

            this.setState({
                externalDependency,
            });
        }, 'external.js');
    }

    componentWillUnmount() {
        const { externalDependency } = this.state;

        externalDependency &amp;&amp; externalDependency.destroy();
    }

    render() {
        const { externalDependency } = this.state;
        const value = externalDependency
            ?  externalDependency.doStuff()
            : 'NOT LOADED YET';

        return &lt;h1&gt;External value: {value}&lt;/h1&gt;;
    }
}

class App extends Component {
    constructor(props) {
        super(props);

        this.state = {
            hide: false,
        };
    }

    componentWillMount() {
        setTimeout(() =&gt; {
            this.setState(() =&gt; ({
                hide: true,
            }));
        }, 0);
    }

    render() {
        if (this.state.hide) {
            return null;
        }

        return &lt;TheComponent /&gt;;
    }
}
</code></pre>

<p>The external dependency, for all the purposes, is just a library. In our case,
the real one listens to some events and some other stuff. For this post,
consider the following external dependency:</p>

<pre><code class="language-js">function ExternalDependency() {
    return {
        create: () =&gt; {
            window.EXTERNAL = 'EXTERNAL';
        },

        doStuff: () =&gt; {
            return 10;
        },

        destroy: () =&gt; {
            delete window.EXTERNAL;
        },
    };
}
</code></pre>

<h1 id="the-problem">The Problem</h1>

<p>The problem given was the following:</p>

<blockquote>
<p>When we include the component on the page and, right afterwards remove it from
the page, the component throws an error and the page stops working.</p>
</blockquote>

<p>Alongside with the error description, we also had the following log:</p>

<pre><code>TypeError: this.state.externalDependency is null
</code></pre>

<h1 id="the-test-setup">The Test Setup</h1>

<p>So, in order to test this problem, we need to simulate this &ldquo;right afterwards&rdquo;
behavior. To do so, we&rsquo;ll render the component on the page, set a timeout (a
short one) and remove the component from the screen.</p>

<p>Consider the following code:</p>

<pre><code class="language-jsx">class App extends Component {
    constructor(props) {
        super(props);

        this.state = {
            hide: false,
        };
    }

    componentWillMount() {
        setTimeout(() =&gt; {
            this.setState(() =&gt; ({
                hide: true,
            }));
        }, 0);
    }

    render() {
        if (this.state.hide) {
            return null;
        }

        return &lt;TheComponent /&gt;;
    }
}
</code></pre>

<h1 id="the-investigation">The Investigation</h1>

<p><strong>Disclaimer:</strong> now that I&rsquo;m explaining this in a blog post, the problem seems
obvious to me. I think this is because the code shown here is really simplified. The real code has some messy parts, some reducers and lots of code that only
made the investigation progress harder.</p>

<p>Looking at the code, we can see that the only place where
<code>this.state.externalDependency</code> can cause this error is inside
<code>componentWillUnmount</code>, because it starts as <code>null</code>. So, what happens is that
the script hasn&rsquo;t finished loading and we&rsquo;re trying to destroy the instance
(that doesn&rsquo;t exist yet).</p>

<p>So, it might be tempting to do the following:</p>

<pre><code class="language-js">const { externalDependency } = this.state;

if (externalDependency) {
    externalDependency.destroy();
}
</code></pre>

<p>It will make the page stop breaking, as now we don&rsquo;t have a <code>TypeError</code>,
however, we will start having this error:</p>

<pre><code>Warning: Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.
</code></pre>

<p>You might think that it&rsquo;s only a <code>Warning</code> and we&rsquo;re good to go, however, that&rsquo;s
not how things work. Now, we <strong>never</strong> call <code>externalDependency.destroy()</code>, so,
we never clear the changes done by <code>externalDependency</code>. In fact, if we now
check <code>window.EXTERNAL</code>, we&rsquo;ll have it with the value <code>&quot;EXTERNAL&quot;</code>.</p>

<pre><code class="language-js">window.EXTERNAL; // &quot;EXTERNAL&quot;
</code></pre>

<h2 id="making-it-clear">Making It Clear</h2>

<p>So, let&rsquo;s recap what&rsquo;s going on, before exploring the solution:</p>

<ol>
<li>The component is rendered on the page</li>
<li>The script pointing to <code>external.js</code> is created on the page, a callback is
registered to, when the script loads, instantiate an instance of
<code>ExternalDependency</code></li>
<li>The component is removed</li>
<li>The <code>componentWillUnmount</code> is triggered (not calling
<code>externalDependency.destroy()</code>, as it wasn&rsquo;t instantiated so far)</li>
<li>The component is removed from the DOM</li>
<li>The script finishes loading</li>
<li>The callback defined in <code>2.</code> is executed</li>
<li>The external dependency is instantiated</li>
<li>The component tries to <code>setState</code> in an unmounted component, which explains
the error before</li>
</ol>

<h1 id="the-solution">The Solution</h1>

<p>While it can be tempting to put something on <code>componentWillUnmount</code>, like a
<code>setState</code> or so, it is not correct and also doesn&rsquo;t make sense.
<code>componentWillUnmount</code> is called when the component is just about to be removed,
there&rsquo;s no &ldquo;hey React, wait a little bit so I can make some stuff here
and I let you know when you can remove me&rdquo;. Also, setting a state on a component
to be unmounted doesn&rsquo;t make sense, as this component is being removed, it will
not render again nor go to any other <code>lifecycle</code> methods.</p>

<h2 id="solution-1-know-when-unmounted">Solution 1: Know When Unmounted</h2>

<p>One solution that I particularly <strong>don&rsquo;t like</strong> is to have an instance property in
your component that allows you to know if the component is being unmounted.
Something like that:</p>

<pre><code class="language-js">componentWillUnmount() {
    this.isUnmounted = true;
    /* ... remaining code ... */
}
</code></pre>

<p>Then, add a guard condition in your code to avoid the callback to run in this
case:</p>

<pre><code class="language-js">addScriptToPage(() =&gt; {
    if (this.isUnmounted) return
    /* ... remaining code ... */
})
</code></pre>

<p>This works, however, imagine that in some new update, the React team decides to
clear all instance properties (our <code>isUnmounted</code> included). We now have our
memory leak again. Basically, with this solution, we&rsquo;re relying on React to set
a property for us and set it in the correct moment, which gives us less control
of our code flow.</p>

<h2 id="solution-2-control-when-to-execute-the-onload-callback">Solution 2: Control When to Execute the <code>onload</code> Callback</h2>

<p>Our final solution and, in my opinion, a most elegant one, is to have an option
to cancel the execution of our script loader. Our problem is that the <code>onload</code>
callback is being called after the component is unmounted, so, if we never call
this callback, we&rsquo;ll not have this problem.</p>

<p>In this case, we can do something like that:</p>

<pre><code class="language-js">function addScriptToPage(callback, src) {
    const script = document.createElement('script');

    script.src = src;
    script.defer = true;
    script.onload = callback;

    document.body.appendChild(script);

    return {
        cancelOnLoad: () =&gt; script.onload = null,
    };
}
</code></pre>

<p>Now, in our component, we need to hold a reference to this returned object when
calling <code>addScriptToPage</code>:</p>

<pre><code class="language-js">componentWillMount() {
    const scriptLoader = addScriptToPage(() =&gt; {/* remaining code */});
    this.setState({ scriptLoader });
}
</code></pre>

<p>Then, when unmounting, we just call <code>cancelOnLoad</code>:</p>

<pre><code class="language-js">componentWillUnmount() {
    /* remaining code */
    this.state.scriptLoader.cancelOnLoad();
}
</code></pre>

<p>This is a lot better, as now we manage this flow. For example, it&rsquo;s also
possible to remove the previously defined script (and save some bytes of our
users data):</p>

<pre><code class="language-js">return {
    cancelOnLoad: () =&gt; {
        script.onload = null;
        document.body.removeChild(script);
    },
};
</code></pre>

<h1 id="finishing">Finishing</h1>

<p>I think this problem was really interesting to show me how a simple script
loader can become a hard problem to debug if we don&rsquo;t think correctly in the
flow which our code is executed.</p>

<p>Also, always remember to cancel/clear stuff, specially the async ones, to avoid
having those kind of problems.</p>

      </article>

      <p class="post-meta">Tags:&nbsp;
        
            
            <a href="https://wmartins.github.io/tags/react">react</a>
        
            ,&nbsp;
            <a href="https://wmartins.github.io/tags/async%20javascript">async javascript</a>
        
      </p>

      

    </div>
  </div>
</div>
    <footer class="footer">
      <div class="p2 wrap">
        <div class="measure mt1 center">
      <nav class="social-icons icons">
<a class="fa fa-rss rss" href="/index.xml"></a>

</nav>

          <small>
            Copyright &#169; 2017<br>
            Powered by <a href="http://gohugo.io/" target="_blank">Hugo</a> &amp; <a href="https://github.com/azmelanar/hugo-theme-pixyll" target="_blank">Pixyll</a>
          </small>
        </div>
      </div>
    </footer>

    
    <script src="/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    
    
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-68493929-1', 'auto');
  ga('send', 'pageview');

</script>



</body>
</html>

